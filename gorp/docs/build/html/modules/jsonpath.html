
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>jsonpath &#8212; gorpy 0.1.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="readfiles" href="readfiles.html" />
    <link rel="prev" title="command line" href="../command%20line.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="jsonpath">
<h1>jsonpath<a class="headerlink" href="#jsonpath" title="Permalink to this headline">¶</a></h1>
<dl class="simple">
<dt>Contains utilities for performing complex searches in nested Python</dt><dd><p>iterables based on both keys/indices and values.
This has been tested (using gorp.test.test_jsonpath) on Python 3.6-3.9.
It might work on 3.5, but no warranty is made except for 3.6-3.9.</p>
</dd>
<dt>The most immediately comparable project in terms of scope is jsonpath_ng,</dt><dd><p>which is fully JsonPath standard-compliant, but which appears to me to
lack some of this module’s power, such as regex matching on keys.</p>
</dd>
<dt>Some things that you can do with this module:</dt><dd><ul class="simple">
<li><p>Use regular expressions to match keys as well as values in dicts.</p></li>
<li><dl class="simple">
<dt>Filter layers of JSON based on comparisons of multiple values (e.g.,</dt><dd><p>get indices 1:10 of an array only if arr[1] &gt; str(arr[2]))</p>
</dd>
</dl>
</li>
<li><p>Mutate JSON at the nodes found by a search.</p></li>
<li><dl class="simple">
<dt>Filter pandas DataFrames using the same query language, while still</dt><dd><p>getting their incredibly fast performance.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>If you prefer not to use a query parser, build layers of filters by an</dt><dd><p>object-oriented approach. See the Filter, GlobalConstraint, Mutator,
and JsonPath classes. Thanks to jsonpath_ng for pioneering this
approach!</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Build arithmetic expressions of the values and keys in an iterable</dt><dd><p>without using eval(). See math_eval, and its workhorse function,
compute(eqn).</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p><strong>FUNCTIONS</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="gorp.jsonpath.json_extract">
<span class="sig-prename descclassname"><span class="pre">gorp.jsonpath.</span></span><span class="sig-name descname"><span class="pre">json_extract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">json</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_full_path_also</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_selectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recursive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fuzzy_keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ask_permission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gorp.jsonpath.json_extract" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt><em>json</em>: an arbitrarily nested Python object, where each layer </dt><dd><p>is a tuple, list, dict, or subclass of dict.</p>
</dd>
<dt><em>filter_path</em>: list of <a class="reference internal" href="#gorp.jsonpath.Filter" title="gorp.jsonpath.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Filter</span></code></a> steps, or single string or number.</dt><dd><p>The preferred form of filter_path is a query string that can be
parsed into a list of Filter layers by parse_json_path.</p>
</dd>
</dl>
<p><em>get_full_path_also</em>: bool, see “Returns”.</p>
<p><em>reverse_selectivity</em>: bool, see “Returns”.</p>
<p><em>recursive</em>: bool, see “Returns”.</p>
<p><em>fuzzy_keys</em>: If True, you can test keys with regular expressions and many 
kinds of mathematical tests.
The drawback of using fuzzy_keys is that arrays and dicts have to be searched
exhaustively in linear time, rather than just going straight to an exact 
index or key in constant time.
fuzzy_keys can be toggled by ‘zz’ in a filter_path query string.</p>
<p><em>sub_func</em>: Function of one variable. 
If this is not None, after the JSON is extracted, the sub_func is applied to 
the terminal nodes by mutate_json.
You can also turn on “sub mode” in a query string by terminating the query 
string with “~~ss”, followed by a string representing the sub_func
that can be parsed by math_eval.compute().</p>
<p><em>ask_permission</em>: only relevant if sub_func is not None. When in “sub mode”, if
ask_permission is True, create an interactive prompt.</p>
<p><strong>Returns:</strong> a list of the children that can be found by paths matched by this 
function.</p>
<dl>
<dt>Notes on optional parameters:</dt><dd><ul class="simple">
<li><p>If reverse_selectivity is True at a given filter layer, the matching</p></li>
</ul>
<dl>
<dt>changes as follows:</dt><dd><ul class="simple">
<li><p>If fuzzy_keys is False, only the matching on values is reversed.</p></li>
<li><p>If fuzzy_keys is True, the matching on both values and keys is</p></li>
</ul>
<p>reversed.</p>
</dd>
</dl>
<ul class="simple">
<li><p>If get_full_path_also is True, return instead a dict mapping</p></li>
</ul>
<p>complete paths (tuples of keys and indices) to the children of those paths.
* If recursive is True, we keep descending until we find a match, even if
the match fails on the first level it’s applied to.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bad_json</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
<span class="go">   &#39;6&#39;: 7,</span>
<span class="go">   &#39;jub&#39;: {&#39;uy&#39;: [1, 2, 3],</span>
<span class="go">           &#39;yu&#39;: [6, {&#39;y&#39;: &#39;b&#39;, &#39;M8&#39;: 9, 1: (3,0)}]}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    filter_path = &#39;^\d+$&#39;) </span>
<span class="go">    # this is a regex match on keys; it doesn&#39;t work by default </span>
<span class="go">ALERT: It looks like you may have tried to match keys with regular expressions</span>
<span class="go">[&#39;\\d&#39;] while not in fuzzy_keys mode. Did you intend this?</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    filter_path = &#39;^\d+$&#39;, fuzzy_keys=True) </span>
<span class="go">    # regexes on keys work with fuzzy_keys=True.</span>
<span class="go">[7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    filter_path = &#39;jub~~@yu~~uy&#39;) </span>
<span class="go">    # look for the children of key &#39;uy&#39; that&#39;s a child of </span>
<span class="go">    # root-level &#39;jub&#39;, but only if &#39;jub&#39; also has the child &#39;yu&#39;.</span>
<span class="go">    # This is non-fuzzy matching, but it works since &#39;jub&#39;, &#39;yu&#39;</span>
<span class="go">    # and &#39;uy&#39; all match keys in json exactly.</span>
<span class="go">[[1, 2, 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    filter_path = &#39;..~~@zz^[a-z]{2}$~~@zznn0&#39;) </span>
<span class="go">    # &#39;zz&#39; toggles fuzzy_keys; the first use turned it on </span>
<span class="go">    # and the second turned it off</span>
<span class="go">[1, 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    fuzzy_keys = True,</span>
<span class="go">    filter_path = &#39;[a-z]{2}~~@nn0&#39;) </span>
<span class="go">    # Matches &#39;jub&#39;, but then tries to find index 0 in graph[&#39;jub&#39;] and can&#39;t</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    filter_path = &#39;..~~@zz[5-8];;nn5:9&#39;, </span>
<span class="go">    get_full_path_also = True) </span>
<span class="go">    # recursively (&#39;..&#39;) looks for keys with a substring in {&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;}</span>
<span class="go">    # OR (&#39;;;&#39;) that have the numeric value in range(5,9) (&#39;nn5:9&#39;)</span>
<span class="go">{(&#39;jub&#39;, &#39;yu&#39;, 1, &#39;M8&#39;): 9, (&#39;6&#39;,): 7}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    filter_path = &#39;[5-8];;nn5:9&#39;)</span>
<span class="go">    # careful! you&#39;re trying to match an IntRange and a regex to keys when not </span>
<span class="go">    # fuzzy_keys. When fuzzy_keys = False, IntRanges only match array indices.</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    filter_path = &#39;..~~@nnint(k)*2&lt;4vvnnstr(v)&gt;`8`&#39;, </span>
<span class="go">    get_full_path_also = True) </span>
<span class="go">    # If fuzzy_keys is False, we can&#39;t use functions like &quot;int(k)*2 &lt; 4&quot;</span>
<span class="go">    # to constrain keys. As a result, we get this error:</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">JsonPathError</span>: <span class="n">When not in fuzzy_keys mode, only IntRange slicers and ints are allowed as key tests.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">small_json</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">},</span>
<span class="go">        {2: &#39;c&#39;}, [6, 7], {3: &#39;d&#39;}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">small_json</span><span class="p">,</span>
<span class="go">        filter_path = &#39;nn:3~~@..~~@ggnn1vvx[0]&lt;x[1]&#39;, </span>
<span class="go">        get_full_path_also = True)</span>
<span class="go">        # The &#39;gg&#39; string before the third layer means that we create a </span>
<span class="go">        # GlobalConstraint that matches the key/index 1,</span>
<span class="go">        # if itbl[0] &lt; itbl[1].</span>
<span class="go">{(0, 1): 2, (1, 1): &#39;b&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">small_json</span><span class="p">,</span>  
<span class="go">        filter_path = &#39;nn:3~~@..~~@ggnn1:3vvnnx[0]&lt;x[1]&#39;,</span>
<span class="go">        get_full_path_also = True)</span>
<span class="go">        # GlobalConstraints only match IntRanges to array indices.</span>
<span class="go">        # IntRanges do not match numeric dict keys in a GlobalConstraint.</span>
<span class="go">{(0, 1): 2, (0, 2): 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    filter_path = &#39;..~~@zz(?i)^[M-Y]||vvnn1:10:2&#39;,</span>
<span class="go">    get_full_path_also = True) </span>
<span class="go">    # The &#39;||&#39; means that at least one key-value pair must match the key</span>
<span class="go">    # constraint OR the value constraint. It doesn&#39;t have to match both.</span>
<span class="go">{(&#39;jub&#39;, &#39;uy&#39;): [1, 2, 3],</span>
<span class="go"> (&#39;jub&#39;, &#39;yu&#39;): [6, {&#39;y&#39;: &#39;b&#39;, &#39;M8&#39;: 9, 1: (3, 0)}],</span>
<span class="go"> (&#39;6&#39;,): 7,</span>
<span class="go"> (&#39;b&#39;,): 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    filter_path = &#39;zz!!\d~~@!!yu&#39;,</span>
<span class="go">    get_full_path_also = True) </span>
<span class="go">    # in this case, &#39;!!&#39; toggles reverse_selectivity on and then off again.</span>
<span class="go">{(&#39;jub&#39;, &#39;yu&#39;): [6, {&#39;y&#39;: &#39;b&#39;, &#39;M8&#39;: 9, 1: (3, 0)}]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    fuzzy_keys = True,</span>
<span class="go">    filter_path = &#39;..~~@(?i)[a-z]+\d~~^^&#39;, </span>
<span class="go">    get_full_path_also = True)</span>
<span class="go">    # &#39;~~^^&#39; means &quot;find the grandparents of the current container&quot;.</span>
<span class="go">    # You could also get the parents with &#39;~~^&#39; or the great-grandparents </span>
<span class="go">    # with &#39;~~^^^&#39;, and so on.</span>
<span class="go">{(&#39;jub&#39;,): {&#39;uy&#39;: [1, 2, 3], &#39;yu&#39;: [6, {&#39;y&#39;: &#39;b&#39;, &#39;M8&#39;: 9, 1: (3, 0)}]}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">31</span><span class="p">},</span> 
<span class="go">    filter_path = &#39;zz^[a-z]vvnnx&gt;3&amp;&amp;str(x)&lt;`3`&#39;, </span>
<span class="go">    get_full_path_also=True)</span>
<span class="go">    # Each value must satisfy BOTH constraints separated by the &#39;&amp;&amp;&#39;.</span>
<span class="go">    # So the key has to start with a lowercase ASCII letter,</span>
<span class="go">    # and the value has to have a numeric value greater than 3 (&quot;x&gt;3&quot;) AND</span>
<span class="go">    # a string value less than &#39;3&#39; (&quot;str(x)&lt;`3`).</span>
<span class="go">{(&#39;a&#39;,): 17}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_extract</span><span class="p">(</span><span class="n">json</span> <span class="o">=</span> <span class="n">bad_json</span><span class="p">,</span>
<span class="go">    filter_path = &quot;ggvvnnstr(x[`b`]) =~ `^\d`~~zz\dvvnnx&lt;4&quot;)</span>
<span class="go">    # The &quot;=~&quot; operator allows regex matching within a compute expression.</span>
<span class="go">[2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gorp.jsonpath.parse_json_path">
<span class="sig-prename descclassname"><span class="pre">gorp.jsonpath.</span></span><span class="sig-name descname"><span class="pre">parse_json_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fuzzy_keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ask_about_ambiguity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gorp.jsonpath.parse_json_path" title="Permalink to this definition">¶</a></dt>
<dd><p><em>x</em>: a string.</p>
<p><em>fuzzy_keys</em>: See the same argument of json_extract.__doc__.</p>
<dl class="simple">
<dt><em>ask_about_ambiguity</em>: Print possibly helpful messages when x appears to have a</dt><dd><p>malformed pipe, a missing ‘nn’ for declaring “compute mode”,
or a missing ‘zz’ for declaring fuzzy_keys mode when using regexes.</p>
</dd>
</dl>
<p>RULES FOR PARSING AN ENTIRE JSON PATH (‘x’):</p>
<blockquote>
<div><ul class="simple">
<li><p>x is split into path layers or substeps by one of the delimiters</p></li>
</ul>
<p>{‘~~’, ‘~~&#64;’, ‘~~^+’), ‘~~}’}.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘~~’ means that the preceding path substep serves as a “check”;</p></li>
</ul>
<p>(de/a)scent to a child or parent cannot proceed unless all checks 
at a path layer are satisfied.
There can be any number of checks at a path layer.</p>
<ul class="simple">
<li><p>‘~~&#64;’ comes at the end of a path layer; it means that once all the</p></li>
</ul>
<p>checks are satisfied at the current path layer, you begin searching 
the CHILDREN of all nodes that satisfied the preceding check.</p>
<ul class="simple">
<li><p>‘~~^+’ also comes at the end of a path layer; it means that</p></li>
</ul>
<p>once all the checks are satisfied at the current path layer, you 
begin searching the n^th ancestor of the current level of json, 
where n is the number of ‘^’ characters.</p>
<ul class="simple">
<li><p>‘~~}’ can be supplied as the last three characters of a path.</p></li>
</ul>
<p>It means that if the all the checks in the current layer of json were
satisfied, you return the CURRENT LAYER, not children or ancestors.</p>
<ul class="simple">
<li><p>Descent-type-search (as specified by ‘~~&#64;’) is the default, so the</p></li>
</ul>
<p>final path layer will always return the children of all matched nodes
unless the path is terminated with ‘~~}’ or ‘~~^+’.</p>
</div></blockquote>
<ul class="simple">
<li><p>‘..’ switches json_extract into recursive search mode.</p></li>
</ul>
<p>Recursive search mode is off by default.</p>
<ul class="simple">
<li><p>‘!!’ as its own path layer or at the beginning of another path layer</p></li>
</ul>
<p>is treated as a special indicator that toggles reverse_selectivity mode.</p>
<ul class="simple">
<li><p>‘zz’ at the beginninng of another path layer toggles fuzzy_keys, which</p></li>
</ul>
<p>changes the fuzzy_keys parameter of the Filters created by this function.</p>
<ul class="simple">
<li><p>‘gg’ at any point in a path layer (including on a “check” filter in a</p></li>
</ul>
<p>multi-substep path layer) creates a GlobalConstraint rather than a Filter.</p>
<ul class="simple">
<li><p>‘~~ss&lt;func of one variable&gt;’ as the FINAL ELEMENT IN A PATH</p></li>
</ul>
<p>(even after ‘~~}’)
ends the path with a <code class="xref py py-class docutils literal notranslate"><span class="pre">Mutator</span></code> object that can be used to perform in-place
transformations on the JSON after paths have been found by 
json_extract() or JsonPath.extract().</p>
</div></blockquote>
<p>RULES FOR PARSING A SINGLE PATH SUBSTEP (performed by parse_json_path_step):</p>
<blockquote>
<div><ul class="simple">
<li><p>‘nn’ at any point in a path substep toggles “compute mode”.</p></li>
</ul>
<p>While the parser is in “compute mode”, it interprets everything as a
mathematical expression, and passes it into <a class="reference internal" href="#math_eval.compute" title="math_eval.compute"><code class="xref py py-func docutils literal notranslate"><span class="pre">math_eval.compute()</span></code></a>.
Thus, it is easier to include string filters at the beginning of a tuple
path substep and numeric filters at the end of a tuple path substep.</p>
<ul class="simple">
<li><p>‘;;’ separates two elements within the path substep.</p></li>
<li><p>‘&amp;&amp;’ separates two elements within the path substep, and every</p></li>
</ul>
<p>consecutive element joined by ‘&amp;&amp;’ is bundled together; 
so ‘cond1;;cond2&amp;&amp;cond3;;cond4’ 
would filter on cond1 OR (cond2 AND cond3) OR cond4.</p>
<ul class="simple">
<li><p>‘vv’ is a delimiter.</p></li>
</ul>
<p>everything after ‘vv’ in the path substep is a filter on VALUES and 
everything before ‘vv’ is a filter on KEYS.</p>
<blockquote>
<div><ul class="simple">
<li><p>Note that ‘vv’ resets the ‘nn’ flag.</p></li>
</ul>
<p>This means that you need to use ‘nn’ to turn on compute mode 
separately for values and keys.
* Note also that for a GlobalConstraint, everything after the ‘vv’ 
flag is a filter on the iterable as a whole.</p>
</div></blockquote>
<ul class="simple">
<li><p>By default, a path substep must match at least one key filter AND at</p></li>
</ul>
<p>least one value filter, assuming both key and value filters are supplied.</p>
<ul class="simple">
<li><p>‘||’ is an optional indicator that can be used with ‘vv’.</p></li>
</ul>
<p>When ‘||’ is supplied, the filter at that path substep only requires that
a key filter OR a value filter is matched.</p>
<blockquote>
<div><ul class="simple">
<li><p>The ‘||’ flag does not do anything when used on a GlobalConstraint.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>When not in compute mode, all strings (including numeric strings) are</p></li>
</ul>
<p>treated as regular expressions if fuzzy_keys = True and not inside a 
<a class="reference internal" href="#gorp.jsonpath.GlobalConstraint" title="gorp.jsonpath.GlobalConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">GlobalConstraint</span></code></a>.
Otherwise, they are treated as plain strings.</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_json_path</span><span class="p">(</span><span class="s2">&quot;nn5:8vv77&quot;</span><span class="p">)</span>
<span class="go">[[Filter(keys_in = [IntRange(5, 8, 1)], vals_in = [&#39;77&#39;], key_or_val = False, action = &#39;down&#39;, fuzzy_keys = False)]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parse_json_path</span><span class="p">(</span><span class="s2">&quot;\d</span><span class="se">\n</span><span class="s2">~~}&quot;</span><span class="p">)</span> <span class="c1"># don&#39;t forget to turn on fuzzy_keys if you want regex!</span>
<span class="go">ALERT: It looks like you may have tried to match keys with regular expressions</span>
<span class="go">[&#39;\d&#39;] while not in fuzzy_keys mode. Did you intend this?</span>
<span class="go">[[Filter(keys_in = [&#39;\d\n&#39;], vals_in = [], key_or_val = False, action = &#39;stay&#39;, fuzzy_keys = False)]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parse_json_path</span><span class="p">(</span><span class="s2">&quot;zzx*3&lt;=4**3&quot;</span><span class="p">)</span>
<span class="go">ALERT: It looks like you may have forgotten to use the &#39;nn&#39; token to indicate that the equation(s)</span>
<span class="go">[&#39;3&lt;=4&#39;] should be treated as math expressions. Did you intend this?</span>
<span class="go">[[Filter(keys_in = [&#39;x*3&lt;=4**3&#39;], vals_in = [], key_or_val = False, action = &#39;down&#39;, fuzzy_keys = True)]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parse_json_path</span><span class="p">(</span><span class="s2">&quot;^[a-z]</span><span class="si">{2}</span><span class="s2">$||vvnnx&lt;3&amp;&amp;x&gt;2;;nn^[23]&quot;</span><span class="p">,</span> <span class="n">fuzzy_keys</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">    # the &quot;nnx&lt;3&amp;&amp;x&gt;2&quot; means that the conditions &quot;x&lt;3&quot; and &quot;x&gt;2&quot; must BOTH be satisfied.</span>
<span class="go">    # The other condition, &quot;^[23]&quot;, wants the value to be a string starting with &#39;2&#39; or </span>
<span class="go">    # &#39;3&#39;. </span>
<span class="go">    # So long as BOTH of the first two conditions OR the third condition is/are satisfied,</span>
<span class="go">    # this vals_in requirement is met.</span>
<span class="go">[[Filter(keys_in = [&quot;^[a-z]{2}$&quot;], vals_in = [[compute(&#39;x&lt;3&#39;), compute(&#39;x&gt;2&#39;)], &quot;^[23]&quot;], key_or_val = True, action = &#39;down&#39;, fuzzy_keys = True)]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parse_json_path</span><span class="p">(</span><span class="s2">&quot;3~~ggnn1:4:2vvnnx[0]&gt;1&quot;</span><span class="p">)</span>
<span class="go">[[Filter(keys_in = [&#39;3&#39;], vals_in = [], key_or_val = False, action = &#39;check&#39;, fuzzy_keys = False), GlobalConstraint(keys_in = [IntRange(1, 4, 2)], vals_in = [compute(&#39;x[0]&gt;1&#39;)], action = &#39;down&#39;)]] </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parse_json_path</span><span class="p">(</span><span class="s1">&#39;..~~@yu~~zzvvuy~~^^&#39;</span><span class="p">)</span>
<span class="go">[&#39;..&#39;, [Filter(keys_in = [&#39;yu&#39;], vals_in = [], key_or_val = False, action = &#39;check&#39;, fuzzy_keys = False)], [Filter(keys_in = [], vals_in = [&#39;uy&#39;], key_or_val = False, action = &#39;up2&#39;, fuzzy_keys = True)], [Filter(keys_in = [&#39;&#39;], vals_in = [], key_or_val = False, action = &#39;down&#39;, fuzzy_keys = True)]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parse_json_path</span><span class="p">(</span><span class="s1">&#39;a~~@nn1:~~}~~ss str(x)&#39;</span><span class="p">)</span>
<span class="go">[[Filter(keys_in = [&#39;a&#39;], vals_in = [], key_or_val = False, action = &#39;down&#39;, fuzzy_keys = False)], [Filter(keys_in = [IntRange(1, inf, 1)], vals_in = [], key_or_val = False, action = &#39;stay&#39;, fuzzy_keys = False)], Mutator(replacement_func = &#39;compute( str(x))&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gorp.jsonpath.mutate_json">
<span class="sig-prename descclassname"><span class="pre">gorp.jsonpath.</span></span><span class="sig-name descname"><span class="pre">mutate_json</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ask_permission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gorp.jsonpath.mutate_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Mutates a nested iterable object in-place by applying func to obj[path].</p>
<p><em>obj</em>: an object containing arbitrarily nested iterables.</p>
<p><em>path</em>: a tuple of keys or indices to follow through the object.</p>
<p><em>func</em>: a function to apply to the child found at the end of the path, OR a 
non-function that everything should be replaced by, regardless of its value.</p>
<p><em>ask_permission</em>: if True, ask before changing the node. Useful when this is 
called repeatedly by other functions.</p>
<p><strong>Returns:</strong> None.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gorp.jsonpath.mutate_json_repeatedly">
<span class="sig-prename descclassname"><span class="pre">gorp.jsonpath.</span></span><span class="sig-name descname"><span class="pre">mutate_json_repeatedly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ask_permission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gorp.jsonpath.mutate_json_repeatedly" title="Permalink to this definition">¶</a></dt>
<dd><p>See mutate_json. This applies the func to obj[path] for each path in paths.</p>
</dd></dl>

<p><strong>LOANER FUNCTION FROM math_eval</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="math_eval.compute">
<span class="sig-prename descclassname"><span class="pre">math_eval.</span></span><span class="sig-name descname"><span class="pre">compute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eqn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#math_eval.compute" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Evaluate a string encoding a mathematical expression of any number of variables</dt><dd><p>(including no variables).</p>
</dd>
<dt>safe: bool. If True, eqn can only contain numbers, arithmetic, comparisons, and the</dt><dd><p>unary functions ‘float’, ‘int’, and ‘not’. All iterables are forbidden in safe mode.
Also, a function produced by compute() with safe = True will raise a
ValueError if supplied any non-numeric inputs.</p>
</dd>
<dt>Notes:</dt><dd><ul>
<li><dl class="simple">
<dt>‘e’, ‘pi’, ‘inf’, ‘True’, and ‘False’ are constants with the values </dt><dd><p>you’d expect.
- You can add more constants using the “constants” dict.</p>
</dd>
</dl>
</li>
<li><p>Variable names may contain only ASCII letters.</p></li>
<li><p>Do not declare variable names; they is determined at runtime.</p></li>
<li><p>Square brackets for array and dict access can be used as in normal Python.</p></li>
<li><p>Returns a function (if variable names were included) or a scalar otherwise.</p></li>
<li><dl class="simple">
<dt>All arithmetic and comparison operators are allowed, as are nested parentheses,</dt><dd><p>as are the logical ‘^’ (xor), ‘&amp;’ (and), and ‘|’ operators.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>IntRange() objects (which act like builtin range() objects, but are treated as</dt><dd><p><em>equal</em> to all integers in the range as well as <em>containing</em> all of them)
can be declared in a compute() expression by the same start:stop:step syntax
that is used to declare a slice in normal Python.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>IntRanges can be used inside array-slicing square brackets in the same way as</dt><dd><p>a normal slice.</p>
</dd>
</dl>
</li>
<li><p>IntRanges support the ‘==’ operation and no other arithmetic operations.</p></li>
<li><dl>
<dt>You can declare a string literal inside a compute expression by surrounding the</dt><dd><p>string in ‘`’ backticks. ‘`’ characters can be included inside the string by
escaping them with ‘'.
- If you want arbitrarily nested string literals (e.g., something like</p>
<blockquote>
<div><p>before a backtick for each level of nesting of that backtick.
So in the compute expression “x+`3+int(`7`+`float(\`4\`)`)`”,
“3+int(<cite>7`+`float(`4`)</cite>)” is a string on level 1,
“7” and “float(<cite>4</cite>)” are strings on level 2, and ‘4’ is a string on level 3.</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><p>Chained comparisons are evaluated left-to-right, unlike in base Python.</p></li>
<li><dl class="simple">
<dt>The logical ‘^’, ‘|’, and ‘&amp;’ operators are evaluated AFTER the comparison </dt><dd><p>operators, unlike in base Python where the logical operators are evaluated 
first.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The following function names are reserved functions of one argument in compute():</dt><dd><ul class="simple">
<li><p>int, float, str, len, sum, tuple, values, not, min, max, sorted.</p></li>
<li><p>These all do the same things as in normal Python (‘values’ means dict.values).</p></li>
<li><p>Unlike in base Python, the “not” function requires parens; so “not(expr)”.</p></li>
<li><dl class="simple">
<dt>Note that since you can’t define arrays of numbers in a compute() expression,</dt><dd><p>you can’t actually use “sum” on anything other than arrays passed in as
variables.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>You can easily add new functions that take one variable as an argument</dt><dd><p>by adding new name-function pairs to the “ufunctions” dict that is defined
above.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>An unfortunate corrolary of the above observation is that if you added enough</dt><dd><p>ufunctions, you could undoubtedly find a way to do something dangerous
with compute().</p>
</dd>
</dl>
</li>
<li><p>You cannot specify a key or the “reversed” parameter for “sorted(x)”.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“map” is also a reserved function of two arguments.</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>“<cite>fun</cite> map itbl” works very much like map(func, itbl) in base Python; it also</dt><dd><p>returns a generator expression applying a function to everything in itbl.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Note that the proper syntax is “x map y”, not map(x,y), because my parser</dt><dd><p>does not support the latter method for calling binary operators.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Also, eqn must be a compute expression of one variable or a function name in</dt><dd><p>ufunctions. Because eqn is a string literal within the context of the
compute() expression, eqn must be backtick-enclosed.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“=~” is a reserved function of two arguments, both strings.</dt><dd><ul class="simple">
<li><p>“<cite>string</cite> =~ <cite>pat</cite>” is equivalent to (re.search(pat, string) is not None).</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“sub” is a reserved function that accepts two arguments.</dt><dd><ul class="simple">
<li><p>The proper syntax is “&lt;string/varname&gt; sub “&lt;regex&gt;//&lt;replacement&gt;”</p></li>
<li><p>The above is equivalent to re.sub(&lt;regex&gt;, &lt;replacement&gt;, &lt;string/varname&gt;)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt>The arithmetic and logic binops work fine for pandas Series and numpy arrays,</dt><dd><p>but the float, str, and int functions only work on scalars.
- To change the type of a numpy array or pandas Series, use the “intar”,</p>
<blockquote>
<div><p>“floatar”, and “strar” functions to change to the type before the “ar”.</p>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<p><strong>CLASSES</strong></p>
<dl class="py class">
<dt class="sig sig-object py" id="gorp.jsonpath.JsonPath">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">gorp.jsonpath.</span></span><span class="sig-name descname"><span class="pre">JsonPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filters_or_query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fuzzy_keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gorp.jsonpath.JsonPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for manipulating and traversing filter paths.</p>
<p><strong>Initialization args:</strong></p>
<p><em>filters_or_query</em>: a list of layers of Filters and GlobalConstraints; or a 
query that can be parsed by parse_json_path and translated into such a list.</p>
<p><em>json</em>: a nested Python object. This can be added later by add_json().</p>
<p><em>fuzzy_keys</em>: See the documentation for the <a class="reference internal" href="#gorp.jsonpath.Filter" title="gorp.jsonpath.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Filter</span></code></a> class and <a class="reference internal" href="#gorp.jsonpath.json_extract" title="gorp.jsonpath.json_extract"><code class="xref py py-func docutils literal notranslate"><span class="pre">json_extract()</span></code></a>.</p>
<p><strong>Attributes:</strong></p>
<p><em>filters</em>: A list of layers of Filters and GlobalConstraints, along with ‘..’ 
and ‘!!’ flags.</p>
<p><em>mutator</em>: The final item in the “filters” list passed in when initialized.
This is a Mutator object that mutates the JSON passed in to this func.</p>
<p><em>curLayer</em>: Tracks what index of the filters the JsonPath will start 
traversing from. This can be manipulated with <a class="reference internal" href="#gorp.jsonpath.JsonPath.descend" title="gorp.jsonpath.JsonPath.descend"><code class="xref py py-func docutils literal notranslate"><span class="pre">JsonPath.descend()</span></code></a> to see how the 
resultset changes.</p>
<dl>
<dt><strong>Methods:</strong></dt><dd><p><em>‘+’</em>: Two JsonPaths can be added together to concatenate their filters; 
the JsonPath produced by (a+b) has a’s JSON.
You can also add a JsonPath to a list of filters, or vice versa.</p>
<p><em>copy()</em>: Returns a new JsonPath with no associated json.</p>
<p><em>descend()</em>: Allows examination of how each filter layer changes the 
resultset.</p>
<p><em>extract()</em>: Like json_extract().</p>
<p><em>sub()</em>: Finds all the paths from extract(), then applies a function to 
each child node found. This is an in-place transformation.</p>
</dd>
</dl>
<p><strong>Other notes:</strong></p>
<p>You can access slices and individual filter layers in a JsonPath with the 
[a:b] or [a] array-slicing notation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gorp.jsonpath.JsonPath.descend">
<span class="sig-prename descclassname"><span class="pre">gorp.jsonpath.JsonPath.</span></span><span class="sig-name descname"><span class="pre">descend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gorp.jsonpath.JsonPath.descend" title="Permalink to this definition">¶</a></dt>
<dd><p>layers: The number of layers of this JsonPath’s filters to traverse.</p>
<p>If layers is None, just use all of the Filters and GlobalConstraints in this
JsonPath.</p>
<p>Returns None, but updates the JsonPath’s resultset so that repeated calls to 
descend() followed by peeks at its resultset show you how its resultset 
evolves as the filters are successively applied.</p>
<p>Note that the traversal starts at self.curLayer, which may not be the first 
layer.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span> <span class="o">=</span> <span class="n">JsonPath</span><span class="p">(</span><span class="s1">&#39;a~~@nn1:&#39;</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span><span class="o">.</span><span class="n">resultset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span><span class="o">.</span><span class="n">curLayer</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span><span class="o">.</span><span class="n">descend</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
<span class="go">    # applies the filter(s) in layer 0, and descends to layer 1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span><span class="o">.</span><span class="n">resultset</span>
<span class="go">{(&#39;a&#39;,): [1, 2, 3]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span><span class="o">.</span><span class="n">descend</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># applies the filters in layer 1, which is the last layer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span><span class="o">.</span><span class="n">resultset</span>
<span class="go">{(&#39;a&#39;, 1): 2, (&#39;a&#39;, 2): 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gorp.jsonpath.JsonPath.extract">
<span class="sig-prename descclassname"><span class="pre">gorp.jsonpath.JsonPath.</span></span><span class="sig-name descname"><span class="pre">extract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gorp.jsonpath.JsonPath.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>With no arguments, this is equivalent to json_extract(self.json).
If layers is an int, it’s equivalent to 
:func:<a href="#id1"><span class="problematic" id="id2">`</span></a>json_extract`(self.json, self.filters[:layers]),
unless one or more layers is ‘..’ or ‘!!’, because ‘..’ and ‘!!’ don’t count
as their own filter layers.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gorp.jsonpath.JsonPath.sub">
<span class="sig-prename descclassname"><span class="pre">gorp.jsonpath.JsonPath.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ask_permission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gorp.jsonpath.JsonPath.sub" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Applies func to the terminal nodes of all the paths found by</dt><dd><p>self.extract(layers).
If func is None, uses this JsonPath’s mutator to alter the JSON.</p>
</dd>
</dl>
<p>See the documentation for <code class="xref py py-func docutils literal notranslate"><span class="pre">mutate_json()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">JsonPath.extract()</span></code>.
WARNING: This is an IN-PLACE transformation.
If you’re concerned about making unintended changes, use ask_permission=True.</p>
<p>PERFORMANCE NOTE: If you intend to use the results from extract() and then 
use sub(), the below will save time by not calling extract() twice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span> <span class="c1"># jp is a JsonPath</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutate_json_repeatedly</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">json</span><span class="p">,</span> <span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">jp</span><span class="o">.</span><span class="n">mutator</span><span class="o">.</span><span class="n">replacement_func</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span> <span class="o">=</span> <span class="n">JsonPath</span><span class="p">(</span><span class="s1">&#39;a~~@nn1:&#39;</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span><span class="o">.</span><span class="n">json</span>
<span class="go">{&#39;a&#39;:[1,6,8], &#39;b&#39;:2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">At path (&#39;a&#39;, 1),</span>
<span class="go">6</span>
<span class="go">    would be replaced by</span>
<span class="go">14.</span>
<span class="go">Do you want to do this? (y/n) y</span>
<span class="go">There are 1 nodes remaining that may be replaced. Do you still want to be asked permission? (y/n) y</span>
<span class="go">At path (&#39;a&#39;, 2),</span>
<span class="go">8</span>
<span class="go">    would be replaced by</span>
<span class="go">18.</span>
<span class="go">Do you want to do this? (y/n) n</span>
<span class="go">Do you want to quit? (y/n) y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">JsonPath</span><span class="p">(</span><span class="s1">&#39;b~~@nn1:&#39;</span><span class="p">,</span> <span class="n">json</span> <span class="o">=</span> <span class="n">jpath_ex</span><span class="o">.</span><span class="n">json</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">    # note that we supplied layers = 1, so this will only traverse the first filter</span>
<span class="go">    # layer before trying to make replacements.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span><span class="o">.</span><span class="n">json</span>
<span class="go">{&#39;a&#39;:[1, 14, 8], &#39;b&#39;:6}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">JsonPath</span><span class="p">(</span><span class="s1">&#39;a~~@nn1:~~ss str(x)&#39;</span><span class="p">,</span> <span class="n">json</span> <span class="o">=</span> <span class="n">jpath_ex</span><span class="o">.</span><span class="n">json</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">ask_permission</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
<span class="go">                                                             layers = 2)</span>
<span class="go">    # Here we are using the syntax of parse_json_path that allows us to add a Mutator</span>
<span class="go">    # to a JsonPath by terminating the JsonPath string with &quot;~~ss&lt;func of 1 variable&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpath_ex</span><span class="o">.</span><span class="n">json</span>
<span class="go">{&#39;a&#39;:[1, &#39;14&#39;, &#39;8&#39;], &#39;b&#39;:6}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="gorp.jsonpath.Filter">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">gorp.jsonpath.</span></span><span class="sig-name descname"><span class="pre">Filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keys_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vals_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_or_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'down'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fuzzy_keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gorp.jsonpath.Filter" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Used to check keys, array indices, and values in nested Python objects.</dt><dd><p>Note that in this context “keys” means both dict keys and array indices.</p>
</dd>
</dl>
<p><strong>Arguments</strong>:</p>
<p><em>keys_in</em>: Function that performs a comparison, IntRange, number, string, or 
tuple that contains any number of nums, strings, comparison funcs, 
<a class="reference internal" href="#math_eval.IntRange" title="math_eval.IntRange"><code class="xref py py-class docutils literal notranslate"><span class="pre">math_eval.IntRange</span></code></a>, or tuples.
If this is a tuple, a key that matches <em>anything</em> in the tuple is a match.
Any tuple within the tuple represents a set of conditions that are 
bundled and must be simultaneously satisfied.
If this is empty, all keys are matched.</p>
<p><em>vals_in</em>: Same as keys_in, but tests values in a key-value pair.</p>
<dl class="simple">
<dt><em>key_or_val</em>: Bool, default False. If true, any key-value pair where the key </dt><dd><p>matches keys_in OR vals_in is considered a match.</p>
</dd>
</dl>
<p><em>action</em>: str: {‘check’, ‘down’, ‘stay’, ‘up’+str(integer)} 
This determines how json_extract treats key-value pairs that are matched 
by this filter.</p>
<blockquote>
<div><ul class="simple">
<li><p>If the action is ‘check’, there must be another filter in the filter</p></li>
</ul>
<p>layer. This filter only makes assertions.
* If the action is ‘down’, json_extract will search downwards (to the
children) of any keys that are matched by this filter.
* If the action is ‘stay’, json_extract will return the container holding 
the keys that match this filter.
* If the action is ‘up’+str(integer), json_extract will search the 
integer^th ancestor (e.g., 1 = parent, 3 = great-grandparent) of the 
key matched by this filter.</p>
</div></blockquote>
<p><em>fuzzy_keys</em>: bool. If False, IntRanges match array indices but not dict keys
and numbers and strings in keys_in must match keys and indices exactly.
If this is True, keys can be tested “fuzzily” by comparison functions and 
IntRanges, and all strings are treated as regular expressions.
Value testing is “fuzzy” regardless of the value of fuzzy_keys.</p>
<p><strong>Other attributes</strong>:</p>
<p><em>keyfuncs</em>: List of functions that perform key matching based on keys_in.
<em>valfuncs</em>: List of functions that perform value matching based on vals_in.</p>
<p><strong>Methods</strong>:</p>
<p><em>in</em>: The test “(k, v) in filt” will return True if the key-value 
pair k,v matches the filter “filt”.</p>
<p><em>callable</em>: “filt(k, v)” returns the same thing as “(k, v) in filt”.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="gorp.jsonpath.GlobalConstraint">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">gorp.jsonpath.</span></span><span class="sig-name descname"><span class="pre">GlobalConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keys_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vals_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'down'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gorp.jsonpath.GlobalConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Whereas the <a class="reference internal" href="#gorp.jsonpath.Filter" title="gorp.jsonpath.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Filter</span></code></a> class checks individual key-value pairs in an array or
dict, the GlobalConstraint is for applying constraints to the whole iterable.</p>
<dl class="simple">
<dt>keys_in: a list/tuple of strings, numbers, or IntRanges.</dt><dd><p>As with a Filter object with fuzzy_keys = False, each string/num in 
keys_in must exactly match at least one key or index in the iterable; no 
regular expressions!</p>
</dd>
<dt>vals_in: a list of functions that each take a single iterable as an argument. </dt><dd><p>These can be generated by the compute() function (which supports array 
and dict slicing and indexing) or they can just be normal Python functions.
Unlike the keyfuncs and valfuncs of a Filter object, constraints can 
operate on multiple key-value pairs in a single iterable, like 
“itbl[‘b’]&gt;=itbl[‘a’]” or “sum(itbl)&gt;0”.</p>
</dd>
</dl>
<p>action: See the description of the “action” argument for Filter objects.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="math_eval.IntRange">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">math_eval.</span></span><span class="sig-name descname"><span class="pre">IntRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#math_eval.IntRange" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A class like a builtin range() object that is treated as <em>equaling</em> all</dt><dd><p>integers in its range as well as <em>containing</em> them.</p>
</dd>
<dt>Like the builtin range, it is iterable. If the stop is +/-infinity, </dt><dd><p>iteration will stop at self.start - 3,141,592 or self.start + 3,141,592.</p>
</dd>
<dt>IntRanges have a slice(arr) method that returns a slice of arr with indices </dt><dd><p>from the IntRange.</p>
</dd>
</dl>
<p>NOTE: IntRange.fromstring(“::x”), where x is a negative integer, will NOT 
have a slice attribute that is equivalent to the slice produced by the “::x” 
syntax in normal Python.</p>
<p>The best way to build an IntRange that slices an array in reverse order 
starting from the last index is to use IntRange.fromstring(“-1::x”) where x 
is a negative integer.</p>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">gorpy</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../command%20line.html">command line</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">jsonpath</a></li>
<li class="toctree-l1"><a class="reference internal" href="readfiles.html">readfiles</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../command%20line.html" title="previous chapter">command line</a></li>
      <li>Next: <a href="readfiles.html" title="next chapter">readfiles</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Mark J Olson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/modules/jsonpath.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>